<html>
<head>
  <style>

  #container{

    background:#000;
    position:absolute;
    top:0px;
    left:0px;

  }

  </style>
</head>
<body>    

  <div id="container"></div>
  <script src="../lib/three.js"></script>
  <script src="../lib/leap.min.js"></script>
  <script src="../src/camera.js"></script>
  <script src="../src/LeapClutchControls.js"></script>
  <script src="../src/LeapPaddleControls.js"></script>
    
  <script>

  var container , camera , scene, renderer , stats, world;

  var controller , controls;

  loadHandModels();

  init();
  animate();
  
  var leftHand, rightHand;
  function loadHandModels() {
    var loader = new THREE.JSONLoader();
    loader.load('../lib/left_hand.json', function (geometry, materials) {
      leftHand = new THREE.SkinnedMesh(geometry, materials[0]);
      scene.add(leftHand);
      console.log('left hand loaded', geometry, materials);
    });
    
    loader.load('../lib/right_hand.json', function (geometry, materials) {
      rightHand = new THREE.SkinnedMesh(geometry, materials[0]);
      scene.add(rightHand);
      console.log('right hand loaded', geometry, materials);
    });
  }
  
  var m1 = new THREE.Matrix4();
  var m2 = new THREE.Matrix4();

  var zeroVector = new THREE.Vector3(0, 0, 0);
  var direction = new THREE.Vector3(0, 0, 0);
  var up = new THREE.Vector3(0, 0, 0);
  function updateHands() {
    var frame = controller.frame();
    if (!frame.valid) return;
    
    var box = frame.interactionBox;
    var lh, rh;
    frame.hands.forEach(function (h) {
      if (h.type == 'left') {
        lh = h;
      } else if (h.type == 'right') {
        rh = h;
      }
    });
    
    updateHand(box, leftHand, lh);
    updateHand(box, rightHand, rh);
  }
  
  var vec4 = new THREE.Vector3();
  function updateHand(box, mesh, hand) {
    if (!hand) {
      if (mesh) mesh.visible = false;
      return;
    }
    mesh.visible = true;
    var norm = box.normalizePoint(hand.palmPosition);
    vec4.fromArray(norm);
    vec4.z *= -1;
    vec4.w = 1;
    // vec4.multiplyScalar(10)
    // console.log(vec4)
    m1.getInverse(camera.projectionMatrix);
    // m1.multiply(camera.matrixWorldInverse)
    vec4.applyMatrix4(m1);
    vec4.applyMatrix4(camera.matrixWorldInverse);
    // vec4.multiplyScalar(10)
    // mesh.position.set(vec4.x/vec4.w, vec4.y/vec4.w, vec4.z/vec4.w);
    mesh.position.set(vec4.x, vec4.y, vec4.z);
    
    direction.fromArray(hand.direction);
    up.fromArray(hand.palmNormal).multiplyScalar(-1);
    mesh.matrix.lookAt(direction, zeroVector, up);
    mesh.quaternion.setFromRotationMatrix(mesh.matrix);
  }

  function init(){
    scene = new THREE.Scene();
    world = new THREE.Object3D();
    scene.add(world);
    scene.add(new THREE.AmbientLight(0x888888));
    var pointLight = new THREE.PointLight(0xFFffff);
    pointLight.position = new THREE.Vector3(-20, 10, 0);
    pointLight.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(pointLight);
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
    camera.position.z = 300;
    console.log( camera );
        

    controller = new Leap.Controller();
    // controller.use('handHold')
    // .use('handEntry')
    // .use('riggedHand', {parent: scene, scale: 2, materialOptions: {wireframe: false}});
        
    cameraModel = new Camera(camera);
    var transModule = new TranslationModule();
    var rotModule = new RotationModule();
    var orbModule = new OrbitModule();
    cameraModel.addModule(transModule);
    // cameraModel.addModule(rotModule);
    cameraModel.addModule(orbModule);
    
    controls1 = new THREE.LeapClutchControls( camera , controller, cameraModel );
    controls2 = new THREE.LeapPaddleControls( camera , controller, cameraModel );

    var material = new THREE.MeshNormalMaterial();

    /*

    SETTING UP STAR FIELD

    */
    for( var i = 0; i < 50; i ++ ){

      geometry = new THREE.Geometry();

      for( var j = 0 ; j < 100; j++ ){

        var vert = new THREE.Vector3();

        vert.x = ( Math.random() - .5 ) * 1000;
        vert.y = ( Math.random() - .5 ) * 1000;
        vert.z = ( Math.random() - .5 ) * 1000;

        geometry.vertices.push( vert );

      }

      var color = new THREE.Color();
      color.r = ( Math.random() * .5 ) +.5;
      color.g = ( Math.random() * .5 ) +.5;
      color.b = ( Math.random() * .5 ) +.5;

      var material = new THREE.ParticleSystemMaterial({
        size:6, 
        color:color.getHex()
      });

      var particles = new THREE.ParticleSystem( geometry , material );

      world.add(particles);
    }

    var material = new THREE.MeshNormalMaterial();
    // var geometry = new THREE.CubeGeometry( 20 , 20 , 20 );
    var geometry = new THREE.SphereGeometry( 20 , 20 , 20 );
    for( var i = 0; i < 100; i ++ ){

      var mesh = new THREE.Mesh( geometry , material );
      mesh.position.x = ( Math.random() - .5 ) * 500;
      mesh.position.y = ( Math.random() - .5 ) * 500;
      mesh.position.z = ( Math.random() - .5 ) * 500;

      mesh.rotation.x = Math.random() * Math.PI;
      mesh.rotation.y = Math.random() * Math.PI;
      mesh.rotation.z = Math.random() * Math.PI;

      world.add( mesh );

    }

    container = document.getElementById( 'container' );
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );      

    controller.connect();


  }


  function animate(){

    controls1.update();
    controls2.update();
    cameraModel.step();
    updateHands();
    renderer.render( scene , camera );

    requestAnimationFrame( animate );

  }


  </script>
</body>
</html>
